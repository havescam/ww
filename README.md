Анализ алгоритма: Сортировка выбором (Selection Sort)
Определение:
Сортировка выбором (Selection Sort) — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом шаге он находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части.

Анализ:

Алгоритм перебирает все элементы и находит наименьший среди оставшихся неотсортированных.

После нахождения минимального значения производится обмен с текущим элементом неотсортированной части.

Внешний цикл выполняет n - 1 итерацию, а внутренний — поиск минимума.

Количество сравнений примерно равно n * (n - 1) / 2.

Временная сложность: O(n²)
Почему O(n²): Используется два вложенных цикла, и общее число сравнений растет пропорционально квадрату элементов.

Анализ алгоритма: Сортировка обменом (пузырьком) (Bubble Sort)
Определение:
Сортировка обменом (Bubble Sort) — это алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Этот процесс повторяется, пока массив не будет полностью отсортирован.

Анализ:

Алгоритм сравнивает парные элементы и переставляет их при необходимости.

Каждый проход "выталкивает" максимальный элемент в конец массива.

При наихудшем исходе выполняется до n - 1 прохода по массиву.

Количество операций также близко к n * (n - 1) / 2.

Временная сложность: O(n²)
Почему O(n²): Два вложенных цикла, внешний регулирует число проходов, внутренний осуществляет сравнения, что приводит к квадратичному росту операций.

Анализ алгоритма: Сортировка вставками (Insertion Sort)
Определение:
Сортировка вставками (Insertion Sort) — это алгоритм, который строит отсортированную последовательность, по одному элементу за раз, вставляя каждый новый элемент в правильную позицию в уже отсортированной части массива.

Анализ:

Массив рассматривается как две части: отсортированная и неотсортированная.

Каждый элемент вставляется в подходящее место, при необходимости сдвигая другие элементы.

Худший случай — когда массив отсортирован в обратном порядке, и каждый новый элемент нужно перемещать в начало.

Лучший случай — когда массив уже отсортирован, и сравнение делается только один раз на итерацию.

Временная сложность: O(n²)
Почему O(n²): Каждый новый элемент вставляется в отсортированную часть, что приводит к линейной зависимости для каждого шага и, как следствие, к квадратичной сумме операций.

Анализ алгоритма: Сортировка слиянием (Merge Sort)
Определение:
Сортировка слиянием (Merge Sort) — это алгоритм, который использует стратегию "разделяй и властвуй". Он рекурсивно разбивает массив на две половины до тех пор, пока не останутся подмассивы из одного элемента, а затем сливает эти подмассивы в отсортированном порядке.

Анализ:

Алгоритм состоит из двух этапов: деление и слияние.

Глубина рекурсии составляет log₂ n уровней, потому что массив делится пополам.

На каждом уровне выполняется операция слияния, затрагивающая все n элементов.

Суммарное количество операций для всех уровней составляет n * log n.

Временная сложность: O(n log n)
Почему O(n log n): Глубина рекурсии растет логарифмически, а работа на каждом уровне зависит линейно от количества элементов.

Анализ алгоритма: Сортировка Шелла (Shell Sort)
Определение:
Сортировка Шелла (Shell Sort) — это алгоритм, который является обобщением сортировки вставками. Он сравнивает и сортирует элементы, находящиеся на определенном расстоянии друг от друга (с использованием последовательности шагов), постепенно уменьшая это расстояние до 1.

Анализ:

На первых этапах сортируются элементы, удаленные друг от друга на расстоянии "шага".

Шаг постепенно уменьшается, что делает массив всё более упорядоченным.

Когда шаг становится равным 1, выполняется обычная сортировка вставками, но уже почти для упорядоченного массива.

Эффективность алгоритма зависит от выбора последовательности шагов.

Временная сложность: O(n log² n)
Почему O(n log² n): Количество проходов по массиву логарифмически зависит от n, а на каждом уровне выполняются почти линейные операции.

Анализ алгоритма: Быстрая сортировка (Quick Sort)
Определение:
Быстрая сортировка (Quick Sort) — это алгоритм, который использует стратегию "разделяй и властвуй". Он выбирает опорный элемент (pivot) и переупорядочивает массив так, чтобы все элементы меньше опорного оказались слева от него, а все большие — справа, после чего рекурсивно применяется к двум подмассивам.

Анализ:

Производительность зависит от выбора опорного элемента.

При удачном разделении массив делится на две равные части, уменьшая глубину рекурсии до log n.

Каждый уровень рекурсии требует O(n) операций для перестановки элементов.

В среднем случае общая сложность равна n log n.

Временная сложность: O(n log n)
Почему O(n log n): Глубина рекурсии логарифмическая, работа на каждом уровне линейная, что в сумме даёт n log n. В худшем случае при неравномерном делении сложность O(n²).

Анализ алгоритма: Пирамидальная сортировка (Heap Sort)
Определение:
Пирамидальная сортировка (Heap Sort) — это алгоритм, который использует структуру данных "двочная куча" (binary heap). Сначала массив преобразуется в max-кучу, где наибольший элемент находится в корне, затем этот элемент перемещается в конец массива, и куча перестраивается для оставшихся элементов.

Анализ:

Сначала выполняется построение max-Heap за O(n).

Затем n раз выполняется операция удаления максимума и восстановления свойств кучи (heapify).

Каждая операция heapify требует O(log n) времени.

Общая работа составляет n * log n.

Временная сложность: O(n log n)
Почему O(n log n): Одна операция построения кучи O(n) и несколько итераций перестройки O(log n) для каждого элемента.

Анализ алгоритма: Последовательный (линейный) поиск (Linear Search)
Определение:
Последовательный поиск (Linear Search) — это алгоритм, который последовательно проверяет каждый элемент массива от начала до конца, пока не будет найден искомый элемент или не будет достигнут конец массива.

Анализ:

Элементы проверяются один за другим.

Если искомое значение присутствует, процесс завершается при совпадении.

Если элемент отсутствует, проходятся все n элементов.

В среднем проверяется половина массива.

Временная сложность: O(n)
Почему O(n): Количество сравнений зависит от количества элементов в массиве и растет линейно.

Анализ алгоритма: Бинарный поиск (Binary Search)
Определение:
Бинарный поиск (Binary Search) — это алгоритм для нахождения позиции элемента в отсортированном массиве. На каждом шаге алгоритм сравнивает искомый элемент с элементом в середине текущего диапазона и, в зависимости от результата сравнения, отбрасывает одну из половин диапазона.

Анализ:

Массив должен быть предварительно отсортирован.

На каждом шаге диапазон поиска делится пополам.

После нескольких итераций диапазон сводится к одному элементу.

Количество необходимых шагов — log₂ n.

Временная сложность: O(log n)
Почему O(log n): Область поиска сокращается вдвое на каждом шаге, что логарифмически уменьшает количество итераций.

Анализ алгоритма: Интерполирующий поиск (Interpolation Search)
Определение:
Интерполирующий поиск (Interpolation Search) — это алгоритм для нахождения элемента в отсортированном массиве, который использует значения искомого элемента и границ диапазона для предсказания его вероятной позиции (по принципу поиска в телефонной книге).

Анализ:

Использует формулу для прогнозирования позиции элемента.

Эффективен, если данные распределены равномерно.

При неравномерном распределении работает медленнее, вплоть до линейного поиска.

Временная сложность: O(log log n)
Почему O(log log n): С помощью интерполяции диапазон поиска уменьшается быстрее, чем при бинарном поиске, что даёт двойной логарифм.

Анализ алгоритма: Поиск по Фибоначчи (Fibonacci Search)
Определение:
Поиск по Фибоначчи (Fibonacci Search) — это алгоритм для нахождения элемента в отсортированном массиве, который использует числа Фибоначчи для определения позиций сравнения. Он делит массив на две части, размеры которых являются последовательными числами Фибоначчи.

Анализ:

Принцип похож на бинарный поиск, но без деления — используется вычитание чисел Фибоначчи.

Эффективен для больших массивов, так как использует только сложение и вычитание.

Размер интервала поиска уменьшается пропорционально логарифму числа элементов.

Временная сложность: O(log n)
Почему O(log n): Количество шагов поиска равно количеству членов последовательности Фибоначчи, необходимых для покрытия диапазона от 1 до n.
