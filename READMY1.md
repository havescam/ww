Вариант 9. 
1. Создайте рекурсивную функцию для проверки, отсортирован ли массив.
 
2. Принцип работы

Назначение функции.

Функция проверяет, упорядочен ли массив по неубыванию: возвращает истину, если для каждой соседней пары a[i] ≤ a[i+1], иначе ложь.

Синтаксис (обобщённо).

Индексовый вариант: функция принимает массив и индекс i; база: если i достиг предпоследнего элемента, вернуть истину; шаг: если a[i] > a[i+1], вернуть ложь, иначе вызвать себя с i+1.
Вариант со «срезом/хвостом»: функция принимает массив; база: длина 0 или 1 — истина; шаг: если arr > arr, ложь; иначе вызвать себя с подмассивом без первого элемента.​

Базовый случай.

Пустой массив, массив из одного элемента или ситуация, когда текущая позиция дошла до последней сравниваемой пары, — это «готовый» отсортированный отрезок; возвращаем истину и завершаем рекурсию.

Проверка пары.

На каждом шаге сравниваются соседние элементы; первое обнаруженное нарушение a[i] > a[i+1] приводит к немедленному возврату ложь без дальнейших вызовов.

Рекурсивный переход.

Если текущая пара корректна, выполняется рекурсивный переход к следующей паре: либо увеличением индекса на 1, либо передачей «хвоста» массива. Логика повторяется до достижения базы или до первого нарушения.

Завершение и корректность.

Если рекурсивные вызовы дошли до базы без нарушений, итог — истина. Корректность обосновывается индукцией: база очевидна; индукционный шаг сохраняет истинность при переходе от i к i+1, пока не будет обнаружено нарушение.

Практические замечания.

Индексовый вариант избегает создания промежуточных копий и предпочтителен при больших входах; вариант со «срезом/хвостом» проще читать, но создаёт дополнительные объекты. Для очень длинных массивов удобнее итеративная проверка из‑за глубины стека, однако для учебных и умеренных входов рекурсивный подход нагляднее.

3. Временная сложность: O(n)

4. Пояснение: Rаждая пара соседних элементов проверяется один раз, а общее число таких сравнений линейно зависит от длины массива.

5. В чем разница между прямой и косвенной рекурсией? Прямая рекурсия — это когда функция вызывает сама себя напрямую внутри своего тела; косвенная рекурсия — когда функция вызывает другую функцию, которая в итоге (напрямую или через цепочку) снова вызывает первую, образуя взаимные вызовы. Прямая проще для анализа и отладки, а косвенная часто распределяет логику между несколькими функциями, но требует особого внимания к базовым условиям, чтобы избежать бесконечного цикла вызовов.

