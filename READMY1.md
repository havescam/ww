Вариант 9. 
1. Создайте рекурсивную функцию для проверки, отсортирован ли массив.
 
2. Рекурсивный алгоритм проверки отсортированности по неубыванию последовательно сравнивает соседние элементы массива и на каждом шаге сдвигается на один индекс вправо; если встречается пара, где левый элемент больше правого, возвращается ложь, иначе при достижении конца массива возвращается истина. Базовый случай — пустой массив, массив из одного элемента или достижение последней сравниваемой пары, что гарантирует завершение и корректность на тривиальных входах. Реализация одинакова по идее во всех трёх языках программирования: сравнение соседних элементов, ранний выход при нарушении порядка, рекурсивный переход к следующему индексу; для очень длинных массивов предпочтительнее итеративный вариант из‑за глубины стека, однако для учебных задач рекурсивный подход удобен и нагляден.

3. Временная сложность: O(n)

4. Пояснение: Rаждая пара соседних элементов проверяется один раз, а общее число таких сравнений линейно зависит от длины массива.

5. В чем разница между прямой и косвенной рекурсией? Прямая рекурсия — это когда функция вызывает сама себя напрямую внутри своего тела; косвенная рекурсия — когда функция вызывает другую функцию, которая в итоге (напрямую или через цепочку) снова вызывает первую, образуя взаимные вызовы. Прямая проще для анализа и отладки, а косвенная часто распределяет логику между несколькими функциями, но требует особого внимания к базовым условиям, чтобы избежать бесконечного цикла вызовов.

