Что такое дерево
Дерево — это иерархическая структура: у каждого узла ровно один родитель (кроме корня) и ноль или больше потомков, при этом циклов нет и структура остаётся связной. Между любыми двумя узлами существует единственный путь, что отличает дерево от общего графа.​

Что такое граф
Граф задаётся множеством вершин и множеством рёбер, каждое ребро соединяет пару вершин; рёбра могут иметь направление или быть безориентированными. В общих графах допустимы циклы и несколько различных путей между двумя вершинами, в отличие от деревьев.​

Реализация дерева
Python: узел обычно оформляют как класс с полем значения и коллекцией потомков; для бинарного дерева — два поля для левого и правого ребёнка, для N-арного — список/словарь детей. Такая модель удобна для рекурсивных операций и обходов по уровням или в глубину.​​

C++: узлы описывают структурой/классом с данными и указателями на потомков; для общего случая используют динамические контейнеры, для бинарного — поля left/right. Управление ресурсами можно упростить умными указателями, сохранив при этом контроль над памятью.​

Java: узлы — это объекты с ссылками на детей; для бинарных деревьев — два поля, для произвольного числа потомков — коллекция (List/Map). Часто применяют специализированные варианты (напр., деревья поиска) для быстрого доступа по ключу.​​

Реализация графа
Python: используют список смежности на базе dict (вершина → список соседей) или матрицу смежности в виде 2D-списка; для задач анализа графов подходят библиотеки уровня networkx/igraph. Выбор представления зависит от плотности графа и требований к операциям.​​

C++: для разреженных графов удобны векторы списков смежности (std::vector<std::vector<int>> или с list), для плотных — матрица смежности. Альтернативно строят граф из объектов-узлов и явных указателей, если нужен тонкий контроль над структурой.​

Java: список смежности реализуют через ArrayList или через Map для произвольных типов вершин; матрицу — через двумерные массивы. Абстракция через интерфейсы упрощает смену представления без переписывания алгоритмов.​

DFS (обход в глубину)
Идея одна: двигаемся из вершины как можно глубже, помечая посещённые, затем откатываемся назад; для деревьев это даёт линейное время по числу узлов. Для графов учитывают посещённость, иначе возможен зациклившийся обход на циклах.​

Python: часто пишут рекурсивный DFS с множеством visited и накоплением результата; для больших графов используют явный стек, чтобы избежать переполнения стека вызовов. Такой подход одинаково работает для ориентированных и неориентированных графов при корректной отметке посещений.​​

C++ и Java: реализация через рекурсию или явный std::stack/Deque; для каждой вершины перебирают соседей/детей и добавляют непосещённые. Асимптотика: для дерева — 
O
(
N
)
O(N), для графа — 
O
(
V
+
E
)
O(V+E), где 
V
V — вершины, 
E
E — рёбра.
