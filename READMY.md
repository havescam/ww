Блочная (корзинная) сортировка 
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив. 
Шаги по строкам кода
n = len(a); if n <= 1: return a[:] — база: пустой/один элемент уже отсортирован.​

mn, mx = min(a), max(a); if mn == mx: return a[:] — все элементы равны, сортировать не нужно.​

buckets_count = max(2, int(math.sqrt(n))) — выбирается число корзин k для распределения диапазона значений.​

buckets = [[] for _ in range(buckets_count)] — создаются пустые корзины.​

idx = int((x - mn) / (mx - mn) * (buckets_count - 1)); buckets[idx].append(x) — вычисляется индекс корзины и элемент добавляется в неё (равномерная разбивка диапазона).​

для каждой корзины: insertion_sort(b); result.extend(b) — локальная сортировка корзин и конкатенация в итоговый массив

Временная сложность: O(n)
Пояснение. Прямопропорционально объему данных растет временная сложность. Время растёт линейно с размером входа n, то есть пропорционально числу обрабатываемых элементов

Блинная сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.
Шаги по строкам
Операция переворота реализована функцией flip_prefix(a, k), которая реверсирует префикс длиной k

k с помощью a[:k] = reversed(a[:k]), это и есть допустимая операция алгоритма.​

Поиск максимума в текущем неотсортированном хвосте делается find_max_index(a, n), просматривающим элементы a[0:n] и запоминающим индекс наибольшего.​

В основном цикле for curr_n in range(n, 1, -1) последовательно фиксируется максимальный элемент в позиции curr_n - 1: сначала поднимаем максимум в начало if max_i != 0: flip_prefix(arr, max_i + 1), затем переносим его на конец хвоста flip_prefix(arr, curr_n).​

Если максимум уже в нужном месте (max_i == curr_n - 1), шаг пропускается, что сокращает число переворотов без нарушения корректности.

Временная сложность O(n^2). 
Пояснение. Прямопропорционально объему данных растет временная сложность

Сортировка бусинами (гравитационная)
Определение: Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.
Шаги по строкам
Каждый элемент массива представляется строкой из единиц: для числа val в строке i записывается val единиц слева направо. Это моделирует ряды бусин на стержнях.

Имитация гравитации: для каждого столбца подсчитывается количество единиц (бусин), затем эти единицы «роняются» вниз — столбец заполняется единицами снизу вверх, остальные позиции становятся нулями.

Считывание результата: после «падения» бусин сумма единиц по каждой строке дает новое значение этой строки. Полученные значения упорядочены по невозрастанию, что соответствует отсортированному массиву.

Временная сложность O(n * m).
Пояснение. Прямопропорционально объему данных растет временная сложность. При увеличении любого из них время растёт линейно относительно него.

Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.
Шаги по строкам:
Шаг 1. Проверяем первый элемент: если arr == target, сразу возвращаем 0. Затем начинаем экспоненциально расширять правую границу i: i принимает значения 1, 2, 4, 8 и так далее, пока i не выйдет за границы массива или arr[i] не станет больше целевого значения.

Шаг 2. Когда рост остановился, диапазон для бинарного поиска равен [i // 2, min(i, n - 1)]. В этом диапазоне целевое значение может находиться, если оно присутствует в массиве.

Шаг 3. Выполняется обычный двоичный поиск по этому диапазону. Если элемент найден, возвращается его индекс, иначе возвращается -1.

Временная сложность O(log n).
Пояснение. Логарифмически объему данных растет временная сложность.

Тернарный поиск (Ternary Search)
Определене: 
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи).

Поиск скачками (Jump Search)
Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи).

Шаги по строкам:

m = int(math.sqrt(n)): выбираем размер прыжка как корень из n, чтобы сбалансировать число прыжков и длину линейного поиска.

while prev < n and arr[min(prev + m, n) - 1] < x:: прыгаем по концам блоков (0, m, 2m, …), пока конец блока меньше искомого x.

left = max(prev - m, 0); right = min(prev, n - 1): определяем границы блока, внутри которого может лежать x.

for i in range(left, min(right + 1, n)):: выполняем линейный поиск внутри найденного блока слева направо.

if arr[i] > x: break: останавливаемся раньше, так как массив отсортирован и дальше будут только большие значения.

Временная сложность O(n)
Прямопропорционально объему данных растет временная сложность, алгоритм уместен для отсортированных массивов при постоянном времени доступа по индексу (random access).


Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне. 
Шаги по строкам:

Сначала проверяется первый элемент. Если он равен целевому значению, ответ найден сразу.​

Затем правая граница диапазона растет экспоненциально: i принимает значения 1, 2, 4, 8 и т.д., пока не выйдет за массив или пока arr[i] не станет больше либо равным целевому значению.​

Полученный диапазон для двоичного поиска равен [i // 2, min(i, n - 1)]. В этом диапазоне выполняется стандартный бинарный поиск.

Временная слоность O(log n).
Пояснение. Логарифмически объему данных растет временная сложность.
